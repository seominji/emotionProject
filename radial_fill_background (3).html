<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radial Fill Background (Extended)</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden}
    body{background:#111}

    #radial-overlay{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:9999;
      background:transparent;
      opacity:1;
      transition:opacity 260ms linear;
      will-change:background,opacity;
    }
  </style>
</head>
<body>
  <script>
    let cancelCurrent = null;

    function createOverlay(){
      const el = document.createElement('div');
      el.id = 'radial-overlay';
      document.body.appendChild(el);
      return el;
    }

    function startRadialFill(centerX, centerY, color = '#ff6b6b', duration = 5000){
      if (cancelCurrent) cancelCurrent();

      const overlay = createOverlay();

      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
      const dx = Math.max(centerX, vw - centerX);
      const dy = Math.max(centerY, vh - centerY);
      const maxDist = Math.hypot(dx, dy);

      const softEdge = 120;
      const easeOutQuad = t => 1 - (1 - t) * (1 - t);

      let rafId;
      const start = performance.now();

      function frame(now){
        const elapsed = now - start;
        let t = Math.min(1, elapsed / duration);
        t = easeOutQuad(t);

        // softEdge 값만큼 추가 반경을 줘서 원이 더 크게 확산되도록 함
        const radius = t * (maxDist + softEdge);

        overlay.style.background = `radial-gradient(circle ${radius}px at ${centerX}px ${centerY}px, ${color} 0px, ${color} ${Math.max(0, radius - softEdge)}px, rgba(0,0,0,0) ${radius}px)`;

        if (elapsed < duration) {
          rafId = requestAnimationFrame(frame);
        } else {
          document.body.style.background = color;
          requestAnimationFrame(() => {
            overlay.style.opacity = '0';
            overlay.addEventListener('transitionend', () => {
              if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
            }, { once: true });
          });
        }
      }

      rafId = requestAnimationFrame(frame);

      cancelCurrent = () => {
        cancelAnimationFrame(rafId);
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        cancelCurrent = null;
      };

      return cancelCurrent;
    }

    window.addEventListener('click', e => {
      startRadialFill(e.clientX, e.clientY);
    });
  </script>
</body>
</html>
